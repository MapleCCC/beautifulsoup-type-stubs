"""
This type stub file was generated by pyright.
"""

import itertools
import sys
from collections import defaultdict
from typing import Any, Optional

from bs4.element import (
    CharsetMetaAttributeValue,
    ContentMetaAttributeValue,
    nonwhitespace_re,
)

from . import _htmlparser

__license__ = "MIT"
__all__ = ["HTMLTreeBuilder", "SAXTreeBuilder", "TreeBuilder", "TreeBuilderRegistry"]
FAST = "fast"
PERMISSIVE = "permissive"
STRICT = "strict"
XML = "xml"
HTML = "html"
HTML_5 = "html5"

class TreeBuilderRegistry(object):
    def __init__(self):
        self.builders_for_feature = ...
        self.builders = ...
    def register(self, treebuilder_class):
        """Register a treebuilder based on its advertised features."""
        ...
    def lookup(self, *features): ...

builder_registry = TreeBuilderRegistry()

class TreeBuilder(object):
    """Turn a document into a Beautiful Soup object tree."""

    NAME = ...
    ALTERNATE_NAMES = ...
    features = ...
    is_xml = ...
    picklable = ...
    empty_element_tags = ...
    DEFAULT_CDATA_LIST_ATTRIBUTES = ...
    DEFAULT_PRESERVE_WHITESPACE_TAGS = ...
    USE_DEFAULT = ...
    TRACKS_LINE_NUMBERS = ...
    def __init__(
        self,
        multi_valued_attributes=...,
        preserve_whitespace_tags=...,
        store_line_numbers=...,
    ):
        """Constructor.

        :param multi_valued_attributes: If this is set to None, the
        TreeBuilder will not turn any values for attributes like
        'class' into lists. Setting this do a dictionary will
        customize this behavior; look at DEFAULT_CDATA_LIST_ATTRIBUTES
        for an example.

        Internally, these are called "CDATA list attributes", but that
        probably doesn't make sense to an end-user, so the argument name
        is `multi_valued_attributes`.

        :param preserve_whitespace_tags: A list of tags to treat
        the way <pre> tags are treated in HTML. Tags in this list
        will have 

        :param store_line_numbers: If the parser keeps track of the
        line numbers and positions of the original markup, that
        information will, by default, be stored in each corresponding
        `Tag` object. You can turn this off by passing
        store_line_numbers=False. If the parser you're using doesn't 
        keep track of this information, then setting store_line_numbers=True
        will do nothing.
        """
        self.soup = ...
        self.cdata_list_attributes = ...
        self.preserve_whitespace_tags = ...
        self.store_line_numbers = ...
    def initialize_soup(self, soup):
        """The BeautifulSoup object has been initialized and is now
        being associated with the TreeBuilder.
        """
        self.soup = ...
    def reset(self): ...
    def can_be_empty_element(self, tag_name):
        """Might a tag with this name be an empty-element tag?

        The final markup may or may not actually present this tag as
        self-closing.

        For instance: an HTMLBuilder does not consider a <p> tag to be
        an empty-element tag (it's not in
        HTMLBuilder.empty_element_tags). This means an empty <p> tag
        will be presented as "<p></p>", not "<p />".

        The default implementation has no opinion about which tags are
        empty-element tags, so a tag will be presented as an
        empty-element tag if and only if it has no contents.
        "<foo></foo>" will become "<foo />", and "<foo>bar</foo>" will
        be left alone.
        """
        ...
    def feed(self, markup): ...
    def prepare_markup(
        self,
        markup,
        user_specified_encoding: Optional[Any] = ...,
        document_declared_encoding: Optional[Any] = ...,
        exclude_encodings: Optional[Any] = ...,
    ): ...
    def test_fragment_to_document(self, fragment):
        """Wrap an HTML fragment to make it look like a document.

        Different parsers do this differently. For instance, lxml
        introduces an empty <head> tag, and html5lib
        doesn't. Abstracting this away lets us write simple tests
        which run HTML fragments through the parser and compare the
        results against other HTML fragments.

        This method should not be used outside of tests.
        """
        ...
    def set_up_substitutions(self, tag): ...
    def _replace_cdata_list_attribute_values(self, tag_name, attrs):
        """Replaces class="foo bar" with class=["foo", "bar"]

        Modifies its input in place.
        """
        ...

class SAXTreeBuilder(TreeBuilder):
    """A Beautiful Soup treebuilder that listens for SAX events."""

    def feed(self, markup): ...
    def close(self): ...
    def startElement(self, name, attrs): ...
    def endElement(self, name): ...
    def startElementNS(self, nsTuple, nodeName, attrs): ...
    def endElementNS(self, nsTuple, nodeName): ...
    def startPrefixMapping(self, prefix, nodeValue): ...
    def endPrefixMapping(self, prefix): ...
    def characters(self, content): ...
    def startDocument(self): ...
    def endDocument(self): ...

class HTMLTreeBuilder(TreeBuilder):
    """This TreeBuilder knows facts about HTML.

    Such as which tags are empty-element tags.
    """

    empty_element_tags = ...
    block_elements = ...
    DEFAULT_CDATA_LIST_ATTRIBUTES = ...
    DEFAULT_PRESERVE_WHITESPACE_TAGS = ...
    def set_up_substitutions(self, tag): ...

def register_treebuilders_from(module):
    """Copy TreeBuilders from the given module into this module."""
    ...

class ParserRejectedMarkup(Exception):
    def __init__(self, message_or_exception):
        """Explain why the parser rejected the given markup, either
        with a textual explanation or another exception.
        """
        ...
